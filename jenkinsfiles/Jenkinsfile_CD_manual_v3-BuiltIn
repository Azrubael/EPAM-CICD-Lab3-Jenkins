// This is the properly tested variant of CD pipeline
// to run it manually or by the schedule

pipeline {
    agent { label "BuiltIn" }

    environment {
        CONTAINER_PORT='3000'
        ACCESS_PORT = ''
        IMAGE_TAG = ''
    }

    stages {
        stage('Set Environment Variables') {
            steps {
                script {
                    if (env.GIT_BRANCH == 'main') {
                        ACCESS_PORT = '3000'
                        IMAGE_TAG = 'nodemain'
                    } else if (env.GIT_BRANCH == 'dev') {
                        ACCESS_PORT = '3001'
                        IMAGE_TAG = 'nodedev'
                    } else {
                        error("Unsupported branch: ${env.GIT_BRANCH}.")
                    }
                }
            }
        }

        stage('Status check') {
            steps {
                echo "Status check >>> ACCESS_PORT = ${ACCESS_PORT}"
                echo "Status check >>> IMAGE_TAG = ${IMAGE_TAG}"
            }
        }

        stage('Fetch Code') {
            steps {
                git url: 'https://github.com/Azrubael/EPAM-CICD-Lab3-Jenkins.git', branch: env.GIT_BRANCH
            }
        }

        stage('Node Build') {
            steps {
                sh '''
                    npm install
                    npm run build
                '''
            }
        }

        stage('Test') {
            steps {
                // Run tests for the Node.js project
                sh 'npm test'
            }
        }

        stage('Docker Build') {
            steps {
                sh "docker build -t ${IMAGE_TAG}:v1.0 ."
            }
        }

        stage('Manage Docker Containers') {
            steps {
                script {
                    // Stop and remove any previously running containers
                    def containerId = sh(script: "docker ps -q --filter 'ancestor=${IMAGE_TAG}:v1.0'", returnStdout: true).trim()
                    if (containerId) {
                        sh "docker stop ${containerId}"
                        sh "docker rm ${containerId}"
                    }
                }
            }
        }

        stage('Docker Run') {
            steps {
                // Run the Docker image in detached mode with port mapping
                // Using --restart unless-stopped to minimize downtime
                sh "docker run -d --restart unless-stopped -p ${ACCESS_PORT}:${CONTAINER_PORT} ${IMAGE_TAG}:v1.0"
            }
        }
    }

    post {
        always {
            // Clean up actions or notifications can go here
            echo 'Pipeline execution completed.'
        }
        failure {
            // Notify or handle failures if needed
            echo 'Pipeline failed!'
        }
    }
}

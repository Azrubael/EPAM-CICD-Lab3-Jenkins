// This is the properly tested variant of CD pipeline
// to run it manually or by the schedule

pipeline {
    agent { label "BuiltIn" }

    environment {
        CONTAINER_PORT='3000'
        ACCESS_PORT = ''
        IMAGE_TAG = ''
        CONTAINER_TAG = ''
    }

    stages {
        stage('Set Environment Variables') {
            steps {
                script {
                    if (env.GIT_BRANCH == 'main') {
                        ACCESS_PORT = '3000'
                        IMAGE_TAG = 'nodemain'
                        CONTAINER_TAG = 'app-main-container'
                    } else if (env.GIT_BRANCH == 'dev') {
                        ACCESS_PORT = '3001'
                        IMAGE_TAG = 'nodedev'
                        CONTAINER_TAG = 'app-dev-container'
                    } else {
                        error("Unsupported branch: ${env.GIT_BRANCH}.")
                    }
                    IMAGE_NAME = "${IMAGE_TAG}:v1.0"
                }
            }
        }

        stage('Status check') {
            steps {
                echo "Status check >>> ACCESS_PORT = ${ACCESS_PORT}"
                echo "Status check >>> IMAGE_TAG = ${IMAGE_TAG}"
            }
        }

        stage('Fetch Code') {
            steps {
                git url: 'https://github.com/Azrubael/EPAM-CICD-Lab3-Jenkins.git', branch: env.GIT_BRANCH
            }
        }

        stage('Node Build') {
            steps {
                sh '''
                    npm install
                    npm run build
                '''
            }
        }

        stage('Test') {
            steps {
                sh 'npm test'
            }
        }

        stage('Manage Docker Containers and Images') {
            steps {
                script {
                    // I'm not sure if it works
                    def containerId = sh(script: "docker ps -q --filter ancestor=${IMAGE_NAME}", returnStdout: true).trim()
                    if (containerId) {
                        sh "docker stop ${containerId}"
                        sh "docker rm ${containerId}"
                    }

                    def is_running = sh(script: "docker ps --filter name=${CONTAINER_TAG}"), returnStdout: true).trim()
                    def is_container = sh(script: "docker ps -a --filter name=${CONTAINER_TAG}", returnStdout: true).trim()
                    def is_image = sh(script: "docker images --filter reference=${IMAGE_NAME}", returnStdout: true).trim()
                    if (is_running) {
                        sh "docker stop ${CONTAINER_TAG}"
                    }
                    if (is_container) {
                        sh "docker rm ${CONTAINER_TAG}"
                    }
                    if (is_image) {
                        sh "docker rmi ${IMAGE_TAG}:v1.0"
                    }
                }
            }
        }

        stage('Docker Build') {
            steps {
                sh "docker build -t ${IMAGE_TAG}:v1.0 ."
            }
        }


        stage('Docker Run') {
            steps {
                // Run the Docker image in detached mode with port mapping
                // Using --restart unless-stopped to minimize downtime
                sh "docker run -d --restart unless-stopped --name ${CONTAINER_TAG} -p ${ACCESS_PORT}:${CONTAINER_PORT} ${IMAGE_TAG}:v1.0"
            }
        }
    }

    post {
        always {
            // Clean up actions or notifications can go here
            echo 'Pipeline execution completed.'
        }
        failure {
            // Notify or handle failures if needed
            echo 'Pipeline failed!'
        }
    }
}
